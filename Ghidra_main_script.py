import re
import os
from ghidra.program.model.symbol import SymbolUtilities
from ghidra.util.task import ConsoleTaskMonitor

# Dictionary to store known suspicious API calls with explanations
suspicious_apis = {
    "CreateProcess": "Creates a new process, often used in process injection or spawning malicious processes.",
    "CreateProcessW": "Creates a new process, often used in process injection or spawning malicious processes.",
    "RegSetValueEx": "Modifies the registry, potentially used for persistence by adding entries to run at startup.",
    "RegSetValueExW": "Modifies the registry, potentially used for persistence by adding entries to run at startup.",
    "WriteFile": "Writes data to a file, which could indicate file manipulation or malware installation.",
    "ReadFile": "Reads data from a file, potentially accessing sensitive information.",
    "DeleteFile": "Deletes a file, which could be used to cover tracks by deleting evidence.",
    "DeleteFileW": "Deletes a file, which could be used to cover tracks by deleting evidence.",
    "CreateRemoteThread": "Creates a thread in another process, often used in process injection techniques.",
    "OpenProcess": "Opens a handle to a process, often a precursor to process injection or manipulation.",
    "OpenProcessToken": "Retrieves a handle to the access token of a process, potentially for privilege escalation.",
    "LoadLibrary": "Loads a DLL into the process, which could be used to load malicious modules.",
    "LoadLibraryW": "Loads a DLL into the process, which could be used to load malicious modules.",
    "GetProcAddress": "Retrieves the address of a function in a DLL, used to dynamically resolve function addresses.",
    "CreateService": "Creates a service, potentially used to maintain persistence.",
    "CreateServiceW": "Creates a service, potentially used to maintain persistence.",
    "StartService": "Starts a previously created service.",
    "StartServiceW": "Starts a previously created service.",
    "ControlService": "Controls a service, possibly used to manipulate system services.",
    "WinExec": "Executes a program, similar to CreateProcess but older and less flexible.",
    "ShellExecute": "Launches a program or opens a file with the associated application, often used in phishing attacks.",
    "ShellExecuteW": "Launches a program or opens a file with the associated application, often used in phishing attacks.",
    "NtCreateFile": "Creates or opens a file, used by malware to manipulate files at a low level.",
    "NtCreateKey": "Creates a registry key, potentially for persistence.",
    "NtWriteFile": "Writes data to a file, another way to manipulate files.",
    "NtDeleteFile": "Deletes a file, similar to DeleteFileW but at a lower level.",
}


def analyze_memory_dlls_and_processes(report_file):
    report_file.write("# Memory Sections\n\n")
    for block in currentProgram.getMemory().getBlocks():
        section_type = 'Executable' if block.isExecute() else 'Loaded'
        report_file.write("**{} Section**: {} @ {}\n".format(section_type, block.getName(), block.getStart()))
    report_file.write("\n")

    report_file.write("# Imported Functions\n\n")
    analyze_imports(report_file)

    report_file.write("# Process and Service Calls\n\n")
    analyze_process_calls(report_file)
    analyze_service_calls(report_file)


def analyze_imports(report_file):
    for symbol in currentProgram.getSymbolTable().getExternalSymbols():
        if symbol.isExternal():
            function_name = symbol.getName()
            library_name = symbol.getParentNamespace().getName()
            description = suspicious_apis.get(function_name, "No specific threat identified.")
            report_file.write("**{}** (from {}): {}\n".format(function_name, library_name, description))


def analyze_calls(calls, comment, report_file):
    for func in currentProgram.getListing().getFunctions(True):
        for instr in currentProgram.getListing().getInstructions(func.getBody(), True):
            if any(call in instr.toString() for call in calls):
                report_file.write(
                    "**Suspicious {} detected** in function **{}** at address {}\n".format(comment, func.getName(),
                                                                                           instr.getAddress()))
                instr.setComment(instr.getAddress(), "{} detected".format(comment))


def analyze_process_calls(report_file):
    analyze_calls(["CreateProcess", "OpenProcess", "TerminateProcess", "CreateRemoteThread", "ShellExecute", "WinExec"],
                  "Process-related call", report_file)


def analyze_service_calls(report_file):
    analyze_calls(["CreateService", "StartService", "OpenService", "ControlService"], "Service-related call",
                  report_file)


def analyze_registry_and_commands(report_file):
    report_file.write("# Registry and Command Patterns\n\n")
    patterns = [r'cmd\.exe', r'reg\s(query|add|delete)', r'net\s(use|start|stop)', r'sc\s(start|stop|config|query)',
                r'wmic\s(process|os|service)', r'services\.msc', r'taskmgr', r'msconfig', "MalwarePersistence",
                r"C:\malware\malware.exe", r"Software\Microsoft\Windows\CurrentVersion\Run"]
    for string in currentProgram.getListing().getDefinedData(True):
        if any(re.search(pat, str(string.getValue())) for pat in patterns):
            report_file.write(
                "**Suspicious Command/Registry**: {} at {}\n".format(string.getValue(), string.getAddress()))
            string.setComment(string.getAddress(), "Suspicious command/registry found")


def main():
    # Prompt user for report file path
    report_file_path = askString("Report File",
                                 "Enter the path to save the analysis report (e.g., C:/path/to/report.txt):")

    if not report_file_path:
        print("[ERROR] No report file path specified. Aborting.")
        return

    try:
        with open(report_file_path, "w") as report_file:
            report_file.write("# Ghidra Malware Analysis Report\n\n")
            report_file.write("[INFO] Analyzing binary loaded in Ghidra\n\n")
            analyze_memory_dlls_and_processes(report_file)
            analyze_registry_and_commands(report_file)
            report_file.write("\n[INFO] Analysis complete.\n")
        print("[INFO] Analysis report saved to {}".format(report_file_path))
    except IOError as e:
        print("[ERROR] Failed to write report file: {}".format(e))


if __name__ == "__main__":
    main()
